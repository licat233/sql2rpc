package table

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path"
	"strings"

	"github.com/licat233/sql2rpc/cmd/common"
	"github.com/licat233/sql2rpc/cmd/model/internal/conf"
	"github.com/licat233/sql2rpc/config"
	"github.com/licat233/sql2rpc/tools"
)

type Table struct {
	Name          string
	Columns       []*common.Column
	HasNameColumn bool
	interfaceName string
	strcutName    string
	findListName  string
	fileName      string
}

func New(name string, columns []*common.Column) *Table {
	lowerName := tools.ToLowerCamel(name)
	camelName := tools.ToCamel(name)
	findList := fmt.Sprintf("FindList(ctx context.Context, pageSize, page int64, keyword string, %s *%s) (resp []*%s, total int64, err error)", lowerName, camelName, camelName)
	filename := fmt.Sprintf("%sModel_extend.go", lowerName)
	filename = common.GenFilePath(filename)
	return &Table{
		Name:          name,
		Columns:       columns,
		HasNameColumn: false,
		interfaceName: fmt.Sprintf("%s_model", lowerName),
		strcutName:    fmt.Sprintf("default%sModel", camelName),
		findListName:  findList,
		fileName:      filename,
	}
}

func (t *Table) String() string {
	// camelName := tools.ToCamel(t.Name)
	var buf = new(bytes.Buffer)
	dir := path.Dir(t.fileName)
	if dir == "." {
		dir, _ = tools.GetCurrentDirectoryName()
	}
	buf.WriteString("// Code generated by sql2rpc. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("\npackage %s\n\n", dir))
	buf.WriteString("import (")
	buf.WriteString("\n\t\"context\"")
	if t.hasName() {
		buf.WriteString("\n\t\"fmt\"")
	}
	buf.WriteString("\n\t\"strings\"\n")
	buf.WriteString("\n\t\"github.com/Masterminds/squirrel\"")
	// buf.WriteString("\n\t\"github.com/zeromicro/go-zero/core/stores/sqlx\"")
	buf.WriteString("\n)\n")

	buf.WriteString("\ntype (")
	buf.WriteString(fmt.Sprintf("\n\t%s interface {", t.interfaceName))

	//如果后续有新增的方法，请在此处添加
	buf.WriteString(fmt.Sprintf("\n\t\t%s", t.findListName))

	buf.WriteString("\n\t}")
	// buf.WriteString(fmt.Sprintf("\n\t%s struct {", t.strcutName))
	// // buf.WriteString("\n\t\tconn  sqlx.SqlConn")
	// // buf.WriteString("\n\t\ttable string")
	// buf.WriteString(fmt.Sprintf("\n\t\t*default%sModel", camelName))
	// buf.WriteString("\n\t}")
	buf.WriteString("\n)\n")

	// buf.WriteString(fmt.Sprintf("\nfunc new%sModel(default%sModel *default%sModel) *%s {", tools.ToCamel(t.strcutName), camelName, camelName, t.strcutName))
	// buf.WriteString(fmt.Sprintf("\n\treturn &%s{", t.strcutName))
	// buf.WriteString(fmt.Sprintf("\n\t\tdefault%sModel,", camelName))
	// buf.WriteString("\n}")
	// buf.WriteString("\n}\n")

	buf.WriteString(t.FindListFunc())
	buf.WriteString(t.TableNameFunc())

	return buf.String()
}

func (t *Table) GenFile() error {
	has, err := tools.PathExists(t.fileName)
	if err != nil {
		return err
	}
	if !has {
		if err = tools.MakeDir(t.fileName); err != nil {
			return err
		}
	}
	_, f, err := tools.RTCFile(t.fileName)
	if err != nil {
		return err
	}
	defer func(f *os.File) {
		e := f.Close()
		if e != nil {
			err = e
		}
	}(f)

	isCache, err := t.IsCacheMode()
	if err != nil {
		return err
	}
	conf.ChangeQueryString(isCache)

	buf := new(bytes.Buffer)

	content := t.String()

	content, _ = tools.FormatGoContent(content)

	buf.WriteString(content)
	// write
	_, err = f.WriteString(buf.String())
	if has {
		fmt.Println(config.UpdatedFileMsg, t.fileName)
	} else {
		fmt.Println(config.CreatedFileMsg, t.fileName)
	}

	err = t.InterfaceExtends()

	return err
}

func (t *Table) FindListFunc() string {
	t.HasNameColumn = t.hasName()
	camelName := tools.ToCamel(t.Name)
	lowerName := tools.ToLowerCamel(t.Name)
	var buf = new(bytes.Buffer)
	funcString := fmt.Sprintf("\nfunc (m *%s) %s {", t.strcutName, t.findListName)
	buf.WriteString(funcString)
	if t.HasNameColumn {
		buf.WriteString("\n\thasName := false")
	}
	baseSq := fmt.Sprintf("\n\tsq := squirrel.Select(%sRows).From(m.table)", lowerName)
	buf.WriteString(baseSq)

	t.thanString(buf)

	buf.WriteString("\n\tif pageSize > 0 && page > 0 {")
	buf.WriteString("\n\t\tsqCount := sq.RemoveLimit().RemoveOffset()")
	buf.WriteString("\n\t\tsq = sq.Limit(uint64(pageSize)).Offset(uint64((page - 1) * pageSize))")
	buf.WriteString("\n\t\tqueryCount, agrsCount, e := sqCount.ToSql()")
	buf.WriteString("\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\treturn\n\t\t}")
	buf.WriteString(fmt.Sprintf("\n\t\tqueryCount = strings.ReplaceAll(queryCount, %sRows, \"COUNT(*)\")", lowerName))
	buf.WriteString("\n\t\tif err = " + conf.QueryRow + "(ctx, &total, queryCount, agrsCount...); err != nil {\n\t\t\treturn\n\t\t}")
	buf.WriteString("\n\t}")
	buf.WriteString("\n\tquery, agrs, err := sq.ToSql()\n\tif err != nil {\n\t\treturn\n\t}")
	buf.WriteString(fmt.Sprintf("\n\tresp = make([]*%s, 0)", camelName))
	buf.WriteString("\n\tif err = " + conf.QueryRows + "(ctx, &resp, query, agrs...); err != nil {\n\t\treturn\n\t}")
	buf.WriteString("\n\treturn")
	buf.WriteString("\n}\n")
	return buf.String()
}

func (t *Table) TableNameFunc() string {
	var buf = new(bytes.Buffer)
	buf.WriteString(fmt.Sprintf("\nfunc (m *%s) TableName() string {", t.strcutName))
	buf.WriteString("\n\treturn m.table")
	buf.WriteString("\n}\n")
	return buf.String()
}

func (t *Table) thanString(buf *bytes.Buffer) {
	basisName := tools.ToLowerCamel(t.Name)
	hasName := false
	buf.WriteString(fmt.Sprintf("\n\tif %s != nil {", basisName))
	for _, c := range t.Columns {
		var than string
		//判断是字符串，还是数字
		tName := convTypeName(c.ColumnType)
		if tName == "number" {
			than = ">= 0"
			if isIdColumn(c.ColumnName) {
				than = "> 0"
			}
		} else if tName == "string" {
			than = "!= \"\""
		} else {
			// fmt.Println("unknow column type:", c.ColumnName, "-", tName, "-", c.ColumnType)
			continue
		}
		cName := tools.ToCamel(c.ColumnName)
		cV := fmt.Sprintf("%s.%s", basisName, cName)
		buf.WriteString(fmt.Sprintf("\n\t\tif %s %s {", cV, than))
		buf.WriteString(fmt.Sprintf("\n\t\t\tsq = sq.Where(\"%s = ?\", %s)", c.ColumnName, cV))
		if strings.ToLower(c.ColumnName) == "name" {
			buf.WriteString("\n\t\t\thasName = true")
			hasName = true
		}
		buf.WriteString("\n\t\t}")
	}
	buf.WriteString("\n\t}")
	if hasName {
		buf.WriteString("\n\tif keyword != \"\" && !hasName {")
		buf.WriteString("\n\t\tsq = sq.Where(\"name LIKE ?\", fmt.Sprintf(\"%%%s%%\", keyword))")
		buf.WriteString("\n\t}")
	}
}

func (t *Table) hasName() bool {
	if t.HasNameColumn {
		return true
	}
	for _, c := range t.Columns {
		if strings.ToLower(c.ColumnName) == "name" {
			tName := convTypeName(c.ColumnType)
			if tName == "string" {
				t.HasNameColumn = true
				return true
			}
			return true
		}
	}
	return false
}

func isIdColumn(name string) bool {
	name = tools.ToSnake(name)
	names := strings.Split(name, "_")
	n := len(names)
	if n == 0 {
		return false
	}
	return names[n-1] == "id"
}

func convTypeName(columnType string) string {
	typ := strings.ToLower(columnType)
	if strings.HasPrefix(typ, "int") || strings.HasSuffix(typ, "int") || strings.HasPrefix(typ, "float") {
		return "number"
	}

	if strings.HasSuffix(typ, "text") || strings.HasSuffix(typ, "char") {
		return "string"
	}

	switch typ {
	case "char", "varchar", "text", "longtext", "mediumtext", "tinytext":
		return "string"
	case "blob", "mediumblob", "longblob", "varbinary", "binary":
		return "bytes"
	case "date", "time", "datetime", "timestamp":
		return "time"
	case "bool", "bit":
		return "bool"
	case "tinyint", "smallint", "int", "mediumint", "bigint":
		return "int64"
	case "float", "decimal", "double":
		return "float64"
	case "json":
		return "string"
	default:
		return ""
	}
}

func (t *Table) IsCacheMode() (bool, error) {
	genFilename := fmt.Sprintf("%sModel_gen.go", tools.ToLowerCamel(t.Name))
	filePath, err := tools.FindFile(config.C.Dir.GetString(), genFilename)
	if err != nil {
		return false, err
	}
	file, err := os.Open(filePath)
	if err != nil {
		return false, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		line = strings.TrimSpace(line)
		if line == "sqlc.CachedConn" {
			return true, nil
		}
	}

	if err := scanner.Err(); err != nil {
		return false, err
	}
	return false, nil
}

func (t *Table) OpenGenModelFile() (*os.File, error) {
	genFilename := fmt.Sprintf("%sModel_gen.go", tools.ToLowerCamel(t.Name))
	filePath, err := tools.FindFile(config.C.Dir.GetString(), genFilename)
	if err != nil {
		return nil, err
	}
	has, err := tools.PathExists(filePath)
	if err != nil {
		return nil, err
	}
	if !has {
		return nil, fmt.Errorf("%s 文件不存在，请先使用goctl工具创建", genFilename)
	}

	// 打开文件以供读取
	file, err := os.OpenFile(filePath, os.O_RDWR, 0644)
	return file, err
}

func (t *Table) InterfaceExtends() error {
	file, err := t.OpenGenModelFile()
	if err != nil {
		return err
	}
	defer file.Close()

	table := tools.ToLowerCamel(t.Name)
	target := fmt.Sprintf("%sModel interface {", table)

	// 使用bufio.Scanner获取文件中每一行的内容
	scanner := bufio.NewScanner(file)

	// 读取每行内容并进行修改
	var exist = false
	var newContent = new(bytes.Buffer)
	for scanner.Scan() {
		line := scanner.Text()
		if exist && strings.HasSuffix(line, t.interfaceName) {
			//已经存在，不需要修改
			return nil
		}
		if strings.HasSuffix(strings.TrimSpace(line), target) {
			exist = true
			line = fmt.Sprintf("%s // extends interface\n\t\t%s", line, t.interfaceName)
		}
		newContent.WriteString(line + "\n")
	}

	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "reading standard input:", err)
		return err
	}

	// 将修改后的内容写回到文件中
	_, err = file.Seek(0, 0)
	if err != nil {
		return err
	}

	_, err = file.WriteString(newContent.String())
	if err != nil {
		fmt.Println("文件写入失败，请检查文件路径是否正确")
		return err
	}

	return nil
}
